### Mysql锁机制：

### 锁机制：

因为Mysql支持多线程方式，所以可以同时处理多个客户端请求。有时为了防止客户端同时修改数据，我们使用锁操作完成。

比如一个用户在修改数据，另一个用户也要修改该条数据，我们可以让第一个用户独占这个表记录，等他操作完再让第二个用户操作。

下面是典型的商城应用，多用户购买商品时可以使用锁机制保障库存的准确性。

#### 储存引擎：

`InnoDB` 是主流储存引擎并支持行级锁的，有更高的并发处理性能，下面来演示行锁的运行过程。`MyIsam`引擎在最新版本的MYSQL中已经废弃所以不过多讨论了。

- 行锁开销大，锁表慢
- 行锁高并发下可并行处理，性能更高
- 行锁是针对索引加的锁，在通过索引检索时才会应用行锁，否则使用表锁
- 在事务执行过程中，随时都可以执行锁定，锁在执行 COMMIT或者ROLLBACK的时候释放

#### 事务处理：

1.A事务执行以下代码但不提交

```sql
BEGIN;
UPDATE stu SET sname = 'hdcms' WHERE id=1;

```

2.B事务执行以下代码，可以正常执行

```sql
BEGIN;
update stu set sname = 'jinronga' where id=3
COMMIT;
```

3.但B事务更新与A事务相同的记录则无法操作，执行过程发生阻塞

```sql
BEGIN;
UPDATE stu SET sname = 'hdcms' WHERE id=1;
...
```

4.当A执行执行`COMMIT` 提交后，解锁记录行这时B事务继续执行

```sql
...
COMMIT;
...
```

### 非索引阻塞

使用非索引字段筛选时，将造成全表锁定即表级锁，应该避免这种情况发生，提升数据库的并发性能。

1. 事务A执行以下代码，因为`sname`字段没有添加索引，造成锁定整个表

```sql
BEGIN;
UPDATE stu SET sname = 'hdcms' WHERE sname ='jinronga';
```

2.现在事务B更新任何一条记录都会造成阻塞，因为现在是表锁状态

```sql
BEGIN;
update stu set sname = '小明' where id=1
-- 阻塞中...
```

3.将 `sname`字段添加索引后，行锁功能就又有效了

### 范围锁

查询没有指定明确范围时也会造成大量记录的锁定

1.事务A筛选时使用了范围区间，将会造成表锁

```sql
BEGIN;
UPDATE goods SET num=200 WHERE id>1 AND id<3; 
```

2.事务B将不能修改表中的ID大于2的记录

```sql
BEGIN;
update goods set num =1 where id=2;
-- 阻塞中...
```

但可以更改ID为1的记录

```sql
update goods set num =1 where id=1;
```

3.执行添加时因为不在id为 1~3的范围内所以可以添加，但如果添加时指定ID为2将会阻塞。

```sql
insert into goods (name,num) values('西瓜',200);
```



##### 悲观锁(Pessimistic Lock)

顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。

##### 乐观锁(Optimistic Lock)

顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。

两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。本质上，数据库的乐观锁做法和悲观锁做法主要就是解决下面假设的场景，避免丢失更新问题：

##### 一个比较清楚的场景

下面这个假设的实际场景可以比较清楚的帮助我们理解这个问题：假设当当网上用户下单买了本书，这时数据库中有条订单号为001的订单，其中有个status字段是’有效’,表示该订单是有效的；

后台管理人员查询到这条001的订单，并且看到状态是有效的用户发现下单的时候下错了，于是撤销订单，假设运行这样一条SQL: update order_table set status = ‘取消’ where order_id = 001;

后台管理人员由于在b这步看到状态有效的，这时，虽然用户在c这步已经撤销了订单，可是管理人员并未刷新界面，看到的订单状态还是有效的，于是点击”发货”按钮，将该订单发到物流部门，同时运行类似如下SQL，将订单状态改成已发货:update order_table set status = ‘已发货’ where order_id = 001

####  表锁机制

针对一些不支持事务的处理引擎可以使用锁表的方式控制业务。



### 读锁

为表设置读锁后，当前会话和其他会话都不可以修改数据，但可以读取表数据。

1.会话A对表goods设置了读锁，将不能修改该表，也不能操作其他表

```sql
LOCK TABLE goods READ;
UPDATE goods SET num=300 WHERE id=1;
SELECT * FROM stu;
```

2.因为会话A对表`goods`设置了读锁，所以会话B也不能修改

```sql
update goods set num=200 where id=1;
-- 阻塞
```

3.会话A解锁表后，其他会话又可以继续操作表了

```sql
UNLOCK TABLES;
```

###  写锁

为表设置了写锁后，当前会话可以修改，查询表，其他会话将无法操作。

1.会话A对表goods设置写锁，本会话可以正常操作表， 并不能操作其他表

```sql
LOCK TABLE goods WRITE;
INSERT INTO goods (name,num )VALUES('我会好好学习java的',300);
```

2.会话B读取/写入/写入表数据都将阻塞

```sql
select * from goods
```

3.会话A解锁表数据后，其他会话都可以正常操作了

```sql
UNLOCK TABLES;
```













