### JVM入门

---


- 请你谈谈你对jvm的理解？java8虚拟机和之前的变化更新？
- 什么是OOM，什么是栈溢出StackOverFlowError？怎么解析？
- jvm常用调优的参数有哪些？
- 内存快照如何抓取，怎么解析Dump文件？知道吗？
- 谈谈jvm中，类加载器你的认识？



### 1.jvm的位置

![image-20200518195307337](jvm入门篇.assets/image-20200518195307337.png)

### 2.jvm的体系结构

JVM是运行在操作系统之上的，它与硬件没有交互，下面是jvm的体系结构：

![image-20200518203306668](jvm入门篇.assets/image-20200518203306668.png)

### 3.类加载器（ClassLoader）

负责加载class文件，class文件在文件开头特定的文件标识（cafe babe），将class文件字节码内容加载到内存中，并将这些内容转换为方法区中的运行时数据结构，并且ClassLoader只负责class的文件的加载，至于它是否可以运行，则由Execution Engine决定。

![image-20200518211110478](jvm入门篇.assets/image-20200518211110478.png)

#### 1.1类加载器的种类：

- **虚拟机自带的加载器**

`     Bootstrap ClassLoader`：C++语言写的根平台加载器，系统类加载器

`  Extension ClassLoader`：Java语言写的扩展类加载器，JDK9之后为平台类加载

- **用户自定义加载器：**

  Java.lang.ClassLoader的子类，用户可以定制类的加载方式

### 4.双亲委派机制

当一个类收到了类的请求的时候，它首先不会尝试自己去加载这个类，而是 把请求委托给父类去完成，每一层次类加载器都是一样，因此所有的加载请求都应该传递到启动类加载器中，只有当父类加载器反馈自己无法完成加载这个请求的时候（它自己的加载路劲下无法找到所需的类），子类加载器才会尝试自己去加载。

**好处：**采用双亲委派的一个好处就是比如加载位于rt.jar包中的类`java.lang.Object`，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同一个Object对象。

> 双亲委派机制保证了沙箱安全

#### 2. 执行引擎

Execution Engine执行引擎负责解释命令，提交给操作系统执行。输入的是**字节码文件**，处理过程是**字节码解析**，输出的是**执行结果**。

### 5.沙箱安全机制（了解即可）

#### 什么是沙箱？

 Java安全模型的核心就是Java沙箱（sandbox），什么是沙箱？沙箱是**一个限制程序运行的环境。**沙箱机制就是将 Java  代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。沙箱主要限制系统资源访问，那系统资源包括什么？——CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。

 所有的Java程序运行都可以指定沙箱，可以定制安全策略。

#### java中的安全模型：

在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱 (Sandbox) 机制。如下图所示

![JDK1.0安全模型](jvm入门篇.assets/1095776-20180111144130504-757642373.gif)

但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的 Java1.1 版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示

![JDK1.1安全模型](jvm入门篇.assets/1095776-20180111144207051-1274870859.gif)

在 Java1.2 版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示

![JDK1.2安全模型](jvm入门篇.assets/1095776-20180111144239051-1741250711.gif)

#### 组成沙箱的基本组件：

- 字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。
- 类装载器（class loader）：其中类装载器在3个方面对Java沙箱起作用

1. 它防止恶意代码去干涉善意的代码；
2. 它守护了被信任的类库边界；
3. 它将代码归入保护域，确定了代码可以进行哪些操作。

 虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。

 类装载器采用的机制是双亲委派模式。1. 从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；

2. 由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。

- 存取控制器（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。
- 安全管理器（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。
- 安全软件包（security package）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：
  1. 安全提供者
  2. 消息摘要
  3. 数字签名
  4. 加密
  5. 鉴别

### 6.Native

Native Interface本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，Java诞生时正是C/C++横行的时候，要想立足，必须有调用C/C++程序，于是就在内存中专门开辟了一块区域处理标记为native的代码，它的具体做法是在Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies(本地方法库)。**native：**凡是带了native关键字看java方法已经达不到了需要运用c/c++

目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备；在现在的企业级应用中已经很少见了。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用Web Service等等。

#### 1 Native Method Stack

本地方法栈的具体做法是再其方法栈中登记native方法，在Execution Engine执行时加载本地方法库。



### 7.PC寄存器

每个线程都有一个程序计数器，是线程私有的，<font color=red>就是一个指针</font>，指向方法区中的方法字节码(**用来存储指向下一条指令的地址，也即将要执行的指令代码**)，由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计，因此不会引起GC问题。

这块内存区域很小，它是当前线程所执行的字节码的**行号指示器**，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。

- 如果执行的是一个Native方法，那这个计数器为空。
- 主要用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存溢出(OutOfMemory=OOM)错误。

### 8.方法区

供各**线程共享**的运行时内存区域。<font color=red>它存储了每个类的结构信息，就是模板</font>；例如运行时常量池(Runtime Constant Pool)、字段和方法数据、构造函数和普通方法的字节码内容。上面讲的**是规范**，具体实现不同虚拟机是不同的，最典型的就是永久代(PermGen Space)和元空间(Mate Space)。

**背下来：**

静态变量、常量、类信息（构造方法，接口定义）、运行时的常量池存在方法区中，但是实例变量存在堆内存中与方法区无关。

static  final Class模板 常量池

### 9.栈

1.栈也叫栈内存（先进后出，后进先出，子弹夹一样），主管Java程序的运行，是在线程创建时创建，它的生命周期是跟随线程的生命周期，线程结束栈内存也就释放，**对于栈来说不存在垃圾回收问题**，只要线程一结束该栈就Over，生命周期和线程一致，是线程私有的。

**栈：**<font color=red>8种基本类型的变量+对象引用的变量+实例方法都是在函数的栈内存中分配的。</font>

#### 2.栈存储

栈帧中主要保存3类数据：

- 本地变量(Local Variables)：输入参数和输出参数以及方法内的变量；
- 栈操作(Operand Stack)：记录出栈、入栈的操作；
- 栈帧数据(Frame Data)：包括类文件、方法等。

> **栈帧**：在java中的方法，到了栈中就是栈帧；即**方法=栈帧。**

#### 3. 栈运行原理

栈中的数据都是以栈帧(Stack Frame)的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法和运行期数据的数据集；当一个方法A被调用时就产生了一个栈帧F1，并被压入到栈中，A方法又调用了B方法，于是产生栈帧F2也被压入栈，B方法又调用了C方法，于是产生栈帧F3被压入栈，以此类推...；执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧....，遵循“先进后出(Frist In Last Out)”原则。

每个**方法执行同时都会创建一个栈帧**，用于**存储局部变量表、操作数栈、动态链接、方法出口**等信息，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在`256K~756K`之间，约等于1MB左右。

![image-20200519100633505](jvm入门篇.assets/image-20200519100633505.png)

如上图示在一个栈中有两个栈帧：

- 栈帧2是最先被调用的方法，先入栈；
- 然后方法2又调用了方法1，栈帧1处于栈顶的位置；
- 栈帧2处于栈底，执行完毕后，依次弹出栈帧1和栈帧2；
- 线程结束，栈释放。

每执行一个方法都会产生一个栈帧，保存到栈的顶部，顶部栈就是当前的方法，该方法执行完毕后会自动将此栈帧出栈。

#### 4.堆栈溢出

Java默认的栈大小是有限的，当一个程序不停的入栈但是不出栈，当**栈被压满**后爆栈了，就会产生**错误**：`Exception in thread "main" java.lang.StackOverflowError`。

#### 5.堆+栈+方法区的交互关系

![image-20200519105809802](jvm入门篇.assets/image-20200519105809802.png)

HotSpot是使用指针的方式来访问对象的：Java堆中会存放访问类元数据(就是访问方法区的模板)的地址，reference存储的就直接是对象的地址(堆中存放的都是new的实际对象数据)。

>栈管运行，堆管存储
>
>HotSpot是Java目前使用范围最广的Java虚拟机。



### 10.三种jvm

**三种最主要的JVM:**

1. Sun公司的HotSpot 是目前使用范围最广的Java虚拟机

2. BEA公司的JRockit（原来的 Bea JRockit）电脑软件，系列产品是一个全面的Java运行时解决方案组合

3. IBM公司的J9 VM 是一个高性能的企业级 Java 虚拟机

### 11.堆

#### 1.Heap堆结构体系简介（jdk1.7）

一个JVM实例只存在一个堆内存，堆内存的大小是可调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，保存所有引用类型的真实信息，以方便执行器执行，堆内存分为三部分：

- Young Generation Space(新生区)，简称**Young/New**
- Tenure Generation Space(养老区)，简称**Old/Tenure**
- Permanent Space(永久区)，简称**Perm**

![image-20200519150824160](jvm入门篇.assets/image-20200519150824160.png)

上图就是java1.7之前的堆结构体系图，java8之后永久存储区改名为**元空间** 元空间逻辑上存在：物理上不存在

**永久区：**

这个区是常驻内存的。用来存放jdk自身携带的class对象，interface元数据

jdk1.6之前：永久代，常量池在方法区

jdk1.7：永久代，但是慢慢退化了，去永久代，常量池在堆中，存在java运行时候的环境或类的

jdk1.8之后：无永久代，常量池在**元空间**

#### 2.Heap堆new对象流程：

新生区的类诞生、成长、消亡的区域，一个类在这里产生、应用、最后被回收器回收，结束生命。新生区有分为两个部分。伊甸区(Eden Space)和幸存者区(Survivor Space)，所有类都是在伊甸园区被new出来的。幸存者区有两个：0区(Survivor 0 Space)和1区(Survivor 1 Space)。

当伊甸园的空间用完时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC又称轻GC)，将伊甸园区中的无引用对象进行销毁。然后将会将伊甸园中剩余的对象移动到幸存者0区；若幸存者0区也满了，再对该区域进行垃圾回收，然后移动到1区。如果1区也满了，将移动到养老区，若最后养老区也满了，那么这时将产生(Major GC，又叫Full GC)，对养老区的内存进行清理。若养老区多次执行Full GC后依然无法腾出空间进行对象保存，就会产生OOM异常：`OutOfMemoryError`.

>如出现`java.lang.OutOfMemoryError:Java heap sapce`，说明Java虚拟机的堆内存不够，原因有二：
>
>1. Java虚拟机的堆内存设置不够，可以通过参数-Xms、-Xmx来调整。
>2. 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集(存在被引用，故无法GC)。

在一个项目中，突然出现了OOM故障，那么该如何排除~研究为什么出错~

- 能够看到代码第几行出错：内存快照分析工具，MAT,Jprofiler
- Dubug，一行行分析代码！

**MAT,Jprofiler作用**

分析Dump内存文件，快速定位内存泄露；

获取堆中的数据

获取大的对象~

....

#### 3 TransferValue

面试题：下面的 str，person.getName()，age打印什么？

```java
public class TestTransferValue {

    public void changValue(String str){
        str="xxx";
    }

    public void changeValue2(Person person){
        person.setName("马云");
    }

    public void changeValue3(int age){
        age=18;
    }
    public static void main(String[] args) {

        TestTransferValue testTransferValue=new TestTransferValue();
        String str="abc";
        testTransferValue.changValue(str);
        System.out.println(str);

        Person person=new Person("马化腾");
        testTransferValue.changeValue2(person);
        System.out.println(person.getName());
        int age=21;
        testTransferValue.changeValue3(age);
        System.out.println(age);
    }
}
```

答案：

```
abc
马云
21
```

### 4 对象生命周期和GC

Java堆从GC的角度还可细分为**新生代**(Eden 区、Form Survivor区和To Survivor区)和**老年代**，堆结构如下图：

![image-20200519220321164](jvm入门篇.assets/image-20200519220321164.png)

#### 4.1.MinorGC的过程：(复制->清空->互换)

- 复制：Eden、SurvivorFrom复制到SurvivorTo，年龄+1

首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到SurvivorFrom区，当Eden区再次触发GC时会扫描Eden区和From区，对这两个区域进行垃圾回收；经过这次回收后还存活的对象，则直接**拷贝到To区**(如果有对象年龄达到老年标准，则复制到老年代区)，同时把这些**对象的年龄+1**。

- 清空：清空Eden、SurvivorFrom

复制操作完毕后，会清空Eden和SurvivorFrom中的对象。

- 互换：SurvivorTo和SurvivorFrom互换

最后，SurvivorTo和SurvivorFrom身份互换，即**复制之后有交换，谁空谁是To**，原SurvivorTo成为下一次GC时的SurvivorFrom区。部分对象会在From和To区域中来回复制，增加年龄；如此交换15次(由JVM参数`MaxTenuringThreshold`决定，该参数默认15)，最终还存活的，就会进入老年代。

#### 4.2 HotSpot内存管理

![image-20200520100159572](jvm入门篇.assets/image-20200520100159572.png)

物理上堆实际只有新生代和老年代，Java中98%的对象是临时对象，在Eden生Eden死，只有极少数才能到老年代。(超大字节的数组)

### 5 永久代(元空间)

方法区(Method Area)和堆一样，是各个线程共享的内存区域，它用于存储虚拟机加载的：类信息+普通常量+静态常量+编译器编译后的代码等等，<font color=red>虽然JVM规范将方法区描述为堆的一个逻辑部分，但它却还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。</font>

对于HotSpot虚拟机，很多开发者习惯将方法区称之为“永久代(Parmanent Gen)”，但严格本质上说两者不同，或者说是使用永久代实现方法区而已，**永久代是方法区的一个实现(相当于方法区是一个接口规范，而永久代就是接口实现)**，JDK7的版本中，已经将原本放在永久代的字符串常量池移走，移动到堆中了。

#### 5.1 永久区(Java7之前)

永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class，Interface的元数据(比如rt.jar包内容、Spring框架必须jar包等等)，也就是说它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被垃圾回收器回收掉的，关闭JVM才会释放此区域所占有的内存。

### 6.堆参数调优入门

以下内容JDK1.8+Hotspot为例。

![image-20200520152938468](jvm入门篇.assets/image-20200520152938468.png)

JDK1.8后将永久代取消了，由元空间取代，元空间的本质和永久代类似；元空间与永久代之间最大的区别在于：永久代使用的是JVM的堆内存，但Java8以后的<font color=red>元空间并不在虚拟机中而是使用本机物理内存。</font>

因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入Native Memory，字符串池和类的静态变量放入Java堆中，这样可以加载多少类的元数据就不再由MaxPermSize控制，而由系统的实际可用空间来控制。

### 6.1堆参数进行调优

以下是堆的几个重要的参数：

- `-Xms`：初始大小，默认为物理内存的1/64；
- `-Xmx`：最大分配内存，默认为物理内存的1/4；
- `-Xss`：设置栈大小；
- `-XX:+PrintGCDetails`：输出详细的GC处理日志。

Java将运行时数据区抽象成了一个类：`Runtime`，使用这个类的一些API可以查看一些堆参数

```java
public class HeapDemo {
    public static void main(String[] args) {
        System.out.println("CPU核心数："+Runtime.getRuntime().availableProcessors());
        //虚拟机占用内存的初始化大小
        System.out.println("-Xms:TOTAL_MEMORY=虚拟机中的内存总量："+(Runtime.getRuntime().totalMemory())/(double)1024/1024+"MB");
        //虚拟机最大分配内存的大小
        System.out.println("-Xmx:MAX_MEMORY = 虚拟机试图占用最大的内存量："+(Runtime.getRuntime().maxMemory())/(double)1024/1024+"MB");
    }
}
```

### 6.2 GC收集日志的消息

为了清晰明了的查看堆中的各种GC情况，编写以下测试类测试内存溢出，并查看GC详细日志。

- 编写测试类

```java
public class HeapDemo1 {

    public static void main(String[] args) {
        String str="hello";

        while (true){
            // Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
            str+=str+new Random().nextInt(88888888)+new Random().nextInt(99999999);
        }
        //        byte[] bytes = new byte[40 * 1024 * 1024];
    }
}
```

- 在IDEA中配置参数：`-Xms10m -Xmx10m -XX:+PrintGCDetails`，将堆的内存设小。

![image-20200520161202747](jvm入门篇.assets/image-20200520161202747.png)

- 运行程序，查看日志信息。

![image-20200520161142088](jvm入门篇.assets/image-20200520161142088.png)

- GC信息查看模板如下：

![GC](http://yanxuan.nosdn.127.net/00ffe9b304ed8429f296989f636b8894.png)

- FGC模板

![FGC](http://yanxuan.nosdn.127.net/88e855c3f353edd0ca601221e6332448.png)



### 14.GC(垃圾回收器）1.常用算法

#### 1 GC是什么(分代收集算法)

GC是Java的垃圾回收机制，主要可以概括为以下几点：

- 次数上频繁收集Young区
- 次数上较少收集Old区
- 基本不动元空间

#### 2.Minor GC和Full GC的区别

- 普通GC：只针对新生代区域的GC，指发生在新生代的垃圾收集动作，因为大多数Java对象存活率都不高，所有Minor GC非常频繁，一般回收速度也比较快。
- 全局GC：指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC(并非绝对的)；Major GC的速度一般要比Minor GC慢上10倍以上。

#### 3 四大算法之：引用计数法

![引用计数法](http://yanxuan.nosdn.127.net/8f44594f7894884b1d47abce7b59461a.png)

#### 4 四大算法之：复制算法(Copying)

**年轻代**中使用的是Minor GC，这种GC算法采用的就是复制算法。

##### 4.1 Minor GC原理

![image-20200519150824160](jvm入门篇.assets/image-20200519150824160.png)

**谁空谁是To区**

Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的存活对象就被移到Old代中，也即一旦收集后，Eden区就变成空的了。当对象在Eden(包括一个Survivor 区域，假设是From区域)出生后，经过一次Minor GC后，如果对象还存活，且能够被另外一块Survivor区域所容纳(上面假设是from区，那么这里就是to区，即to区域有足够的内存空间来存储Eden和from区中存活的对象)，则使用复制算法将这些仍然存活的对象复制到另外一块Survivor区(即to区)中，然后清理所使用过的Eden区以及Survivor区(即from区)， 并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过`-XX:MaxTenuringThreshold `来设定参数)，这些对象就会成为老年代。

` -XX:MaxTenuringThreshold` ：设置对象在新生代中存活的次数  



#### 4.2复制算法详细运行的步骤

**HotSpot JVM**将年轻带分为了三部分：**1个Eden区和2个Survivor区**(分别叫from和to)。默认比例为**8:1:1**，一般情况下，**新**创建的对象都会被分配到**Eden区**(一些大对象会特殊处理)，这些对象经过第一次Minor GC后，如果仍然存活，将会被移到**Survivor区**。

对象在Survivor区中每熬过一次Minor GC，年龄就会**增加一岁**，当它的年龄到一定程度后，就会被移动到老年代。因为年轻代中的对象基本都是朝生夕死(90%以上)，所以在**年轻代的垃圾回收算法使用的是复制算法**，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。**复制算法是不会产生内存碎片的。**

![复制算法](http://yanxuan.nosdn.127.net/1941abf352c68e64f498523fecac9094.png)

在GC开始时，对象只会存在于Eden区和名为"From"的Survivor区，Survivor区的"To"是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到"To"，而在"From"区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值的对象会被移到到年老代中，没有达到阈值的对象会被复制到"To"区域。

经过这次GC后，Eden区和From区已经被清空。这时，"From"和"To"会**交换他们的角色**，也就是新的"To"就是上次GC前的"From"，新的"From"就是上次GC前的"To"。

不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到"To"区被填满，"To"区被填满后，会将所有对象移动到年老代中。

![复制算法图示](http://yanxuan.nosdn.127.net/cfc8f3ea53603eda81f723d6632cda1c.png)

因为Eden区对象一般存活率较低，通常使用两块10%的内存作为空闲和活动区间，另外80%的内存用于给新建对象分配内存的。

一旦发生GC，将10%的from活动区间与另外80%中**存活的**Eden对象转移到10%的to空闲区间，接下来，将之前90%的内存全部释放，依次类推。

#### 4.3 复制算法的劣势

#### 

1. 它会浪费了一半内存；
2. 如果对象的存活率过高，假设是100%，那么需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所花费的时间，在对象存活率达到一定程度时，将会变得不可忽视。所以从以上描述不难看出，复制算法想要使用，最起码对象的存活率要非常低才行，而且最重要的是，必须克服50%内存的浪费。

> 简言之：复制算法优点速度快，缺点耗内存，**空间换时间。**

#### 5 四大算法之：标记清除(Mark-Sweep)

##### 5.1 原理

算法分成**标记和清除**两个阶段，先标记出要回收的对象，然后统一回收这些对象

![标记清除](http://yanxuan.nosdn.127.net/08ef0f765737522efedbe254227093eb.png)

用通俗的话解释一下标记清除算法，就是当程序运行期间，若可以使用的内存被耗尽的时候，GC线程就会被触发并将**程序暂停**，随后将要回收的对象标记一遍，最终统一回收这些对象，完成标记清理工作接下来便让应用程序恢复运行。 

主要进行两项工作，第一项则是标记，第二项则是清除。

- 标记：从引用根节点开始标记遍历所有的GC Roots， 先标记出要回收的对象。
- 清除：遍历整个堆，把标记的对象清除。 

##### 5.2 标记清除的优缺点

- 优点：不需要额外的空间，节省内存
- 缺点：
  -  首先，它的缺点就是**效率比较低**（递归与全堆对象遍历，两次扫描），而且在进行GC的时候，需要**停止应用程序**，这会导致用户体验非常差劲；
  -  其次，主要的缺点则是这种方式清理出来的**空闲内存是不连续**的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就不得不维持一个内存的空闲列表，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。   

> 简言之：标记清除算法优点节省内存，缺点两次扫描耗时严重且会产生内存碎片；**时间换空间**。

#### 6 四大算法之：标记压缩(Mark-Compact)

**老年代**一般是由标记清除或者是标记清除与标记整理的混合实现。



**6.1 原理**

![标记压缩](http://yanxuan.nosdn.127.net/9e17861745a6a56bc4599b6eb73b3d20.png)

在整理压缩阶段，不再对标记的对象做回收，而是通过所有存活对象都向一端移动，然后直接清除边界以外的内存。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。

标记/整理算法不仅可以弥补标记/清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价；当然并非没有缺点。

**6.2 劣势**

标记/整理算法唯一的缺点就是**效率也不高**，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。 

### 7 小结

GC算法对比：

- 内存效率：复制算法>标记清除算法>标记整理算法(只是简单的对比时间复杂度，实际情况不一定)
- 内存整齐度：复制算法=标记整理算法>标记清除算法
- 内存利用率：标记整理算法=标记清除算法>复制算法

可以看出，效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存，而为了尽量兼顾上面所提到的三个指标，标记/整理算法相对来说更平滑一些，但效率上依然不尽如人意，它比复制算法多了一个标记的阶段，又比标记/清除多了一个整理内存的过程

难道就没有一种最优算法吗？ 回答：无，没有最好的算法，只有最合适的算法。==========>分代收集算法。 

- 年轻代(Young Gen)

年轻代特点是区域相对老年代较小，对象存活率低。 这种情况**复制算法的回收整理**，速度是最快的。复制算法的效率只和当前存活对像大小有关，因而很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。

- 老年代(Tenure Gen)

老年代的特点是区域较大，对像存活率高。 这种情况，存在大量存活率高的对像，复制算法明显变得不合适。一般是**由标记清除或者是标记清除**与标记整理的混合实现。

Mark阶段的开销与存活对像的数量成正比，这点上说来，对于老年代，标记清除或者标记整理有一些不符，但可以通过多核/线程利用，对并发、并行的形式提标记效率。

Sweep阶段的开销与所管理区域的大小形正相关，但Sweep“就地处决”的特点(原地操作)，回收的过程没有对像的移动。使其相对其它有对像移动步骤的回收算法，仍然是效率最好的。但是需要解决内存碎片问题。

Compact阶段的开销与存活对像的数据成开比，如上一条所描述，对于大量对像的移动是很大开销的，做为老年代的第一选择并不合适。

基于上面的考虑，老年代一般是由标记清除或者是标记清除与标记整理的混合实现。以hotspot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对像的回收效率很高，而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器做为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。   

 8 垃圾收集器

HotSpot虚拟机所包含的所有收集器如下：

![GC收集器](http://yanxuan.nosdn.127.net/cb249e5b59351271d034be26a1e9fa81.png)

新生代收集器：Serial、PraNew、Parallel Scavenge

老年代收集器：Serial Old、Parallel Old、CMS

#### 1. Serial收集器

最基本、发展历史最久的收集器，这个收集器是一个采用复制算法的单线程收集器，单线程一方面意味着它只会使用一个CPU或者一条线程去完成垃圾收集工作，另一方面也意味着它进行垃圾收集时必须暂停其他线程的所有工作，直到它收集结束为止。这说明要在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用是难以接受的。

不过实际上到目前为止，Serial收集器依然是虚拟机运行在Client模式下的默认新生代收集器，因为它简单而高效。用户桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大，收集几十兆或几百兆的新生代停顿时间在几十毫秒最多一百毫秒，只要不是频繁发生，这点停顿完全是可以接受的。Serial收集器运行过程如下图：

![Serial](http://yanxuan.nosdn.127.net/15d6c3a341a0ceac1812d352514e5ac9.png)

#### 2. ParNew收集器

ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集外，其余行为和Serial收集器完全一样，包括使用的算法也是复制算法。ParNew收集器除了多线程以外和Serial收集器并没有太多创新的地方，但是它却是Server模式下的虚拟机首选的新生代收集器，其中有一个很重要的和性能无关的原因是，除了Serial收集器外，目前只有它能喝CMS收集器配合工作(如图)。CMS收集器是一款几乎可以认为有划时代意义的垃圾收集器，因为它第一次实现了让垃圾收集线程与用户线程基本同时工作。ParNew收集器在单CPU环境中绝对不会比Serial收集器有更好的效果，甚至由于线程交互的开销，该收集器在两个CPU的环境中都不能百分百保证可以超越Serial收集器。当然，随着CPU数量的增加，它对于GC时系统资源的有效利用还有很有好处的。它默认开启的收集线程数与CPU数量相同，在CPU数量非常多的情况下，可以使用`-XX:ParallelGCThreads`参数来限制垃圾收集的线程数。ParNew收集器运行过程如下：

![ParNew](http://yanxuan.nosdn.127.net/731aed54eb8e6ceaffef9e5cf1c46ad7.png)



#### 3. Parallel Scavenge收集器

Parallel Scavenge收集器也是一个新生代收集器，使用的复制算法，也是并行的多线程收集器，但它的特点是它的关注点和其他收集器不同。介绍这个收集器主要还是介绍吞吐量的概念。

CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。所谓吞吐量的意思就是CPU用于运行用户代码时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，虚拟机总运行100分钟，垃圾收集1分钟，那吞吐量就是99%。另外，Parallel Scavenge收集器是虚拟机运行在Server面模式下的默认垃圾收集器。

停顿时间短适合需要与用户交互的程序，良好的响应速度能提升用户体验；高吞吐量则可以高效率利用CPU时间，尽快完成运算任务，主要适合在后台运算而不需要太多交互的任务。 

 虚拟机提供了`-XX:MaxGCPauseMillis`和`-XX:GCTimeRatio`两个参数来精确控制最大垃圾收集停顿时间和吞吐量大小。不过不要以为前者越小越好，GC停顿时间的缩短是以牺牲吞吐量和新生代空间换取的。由于与吞吐量关系密切，**Parallel Scavenge收集器也被称为“吞吐量优先收集器”**。Parallel Scavenge收集器有一个`-XX:+UseAdaptiveSizePolicy`参数，这是一个开关参数，这个参数打开之后，就不需要手动指定新生代大小、Eden区和Survivor参数等细节参数了，虚拟机会根据当前系统的运行情况和性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。**如果对于垃圾收集器运作原理不太了解，以至于在优化比较困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择**。 

#### 4. Serial Old收集器

**Serial收集器的老年代版本，同样是一个单线程收集器，**使用"**标记-整理算法**"，这个收集器的主要意义也是在于给Client模式下的虚拟机使用。 

#### 5. Parallel Old收集器

**Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法**。这个收集器在JDK 1.6之后的出现，“吞吐量优先收集器”终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge收集器+Parallel Old收集器的组合。运行过程如下图所示： 

![Parallel Old](http://yanxuan.nosdn.127.net/ce3e4abdc8039eb7fb15712a0a5376f1.png)

#### 6. CMS收集器

CMS(Concurrent Mark Sweep)收集器是以获取最短回收停顿时间为目标的收集器。使用标记-清除算法，收集过程分如下四步：

1. 初始标记，标记GCRoots能直接关联到的对象，时间很短。
2. 并发标记，进行GCRoots Tracing(可达性分析)过程，时间很长。
3. 重新标记，修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，时间较长。
4. 并发清除，回收内存空间，时间很长。

其中，并发标记和并发清除两个阶段耗时最长，但可以与用户线程并发执行。运行过程如下：



说明：

1.  对CPU资源非常敏感，可能会导致应用程序变慢，吞吐率下降。
2.  无法处理浮动垃圾，因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾，同时，由于用户线程并发执行，所以需要预留一部分老年代空间提供并发收集时程序运行使用。
3.  由于采用的标记 - 清除算法，会产生大量的内存碎片，不利于大对象的分配，可能会提前触发一次Full GC。虚拟机提供了`-XX:+UseCMSCompactAtFullCollection`参数来进行碎片的合并整理过程，这样会使得停顿时间变长，虚拟机还提供了一个参数配置，`-XX:+CMSFullGCsBeforeCompaction`，用于设置执行多少次不压缩的Full GC后，接着来一次带压缩的GC。 

#### 7. G1收集器

G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与其他GC收集器相比，G1收集器有以下特点：

1. 并行和并发：使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。
2. 分代收集：独立管理整个堆，但是能够采用不同的方式去处理新创建对象和已经存活了一段时间，熬过多次GC的旧对象，以获取更好的收集效果。
3. 空间整合：基于标记-整理算法，无内存碎片产生。
4. 可预测的停顿：能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

在G1之前的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分（可以不连续）Region的集合。 



## 5. 总结

### 5.1 小结&面试题

1. JVM结构

   1. 有哪几种类加载器？
   2. 双亲委派机制
   3. 沙箱安全

2. Native

   1. native是一个关键字么？
   2. native方法只有声明，没有实现。

3. 寄存器

   1. 记录了方法之间的调用和执行情况，类似排班值日表；用来存储指向下一条指令的地址，也即将要执行的指令代码，它是当前线程所执行的字节码的**行号指示器**。

4. 方法区

   1. 线程共享的运行时内存区域，存储了类的结构信息(模板)
   2. 是一个JVM规范，具体实现不同虚拟机是不同的，例如永久代和元空间

5. 栈

   1. 栈内存主管Java程序运行，生命周期跟随线程生命周期，不存在GC问题。
   2. 栈帧中主要存储3类数据：本地变量、栈操作、栈帧数据。
   3. 栈运行原理？

6. 堆内存

   1. 堆内存模型：新生区，养老区、永久代
   2. 堆new对象流程，新生区内存划分
   3. 轻GC的过程
   4. 什么是永久代？
   5. `-Xms`、`-Xmx`是干嘛的？

7. GC

   1. GC是什么？
   2. Minor GC和Full GC的区别？
   3. GC有哪些算法？
   4. GC使用哪个算法最好？

   ## 6. 参考

   1. 尚硅谷周阳JVM课程笔记，感谢阳哥
   2. https://www.cnblogs.com/xiaoxi/p/6486852.html 

15.JMM

